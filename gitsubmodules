#!/usr/bin/env bash
#
# Automates update of git submodules in parent repo.
# Checks out main/dev branches in each submodule owned by GITHUB_USERNAME,
# merges main into dev, pushes changes, and updates parent repo if submodules changed.
#
# @author Linus Fernandes (linusfernandes@gmail.com)
# @copyright Copyright (c) Linus Fernandes

# shellcheck disable=SC2155,SC1090,SC1091,SC2015
set -euo pipefail
shopt -s inherit_errexit
# --- Constants ---
readonly SCRIPT_NAME="$(basename "$0")"
readonly EXIT_SUCCESS=0
readonly EXIT_FAILURE=1
readonly EXIT_USAGE=2
readonly REQUIRED_UTILS=("git")

readonly COLOR_RED="\033[0;31m"
readonly COLOR_GREEN="\033[0;32m"
readonly COLOR_YELLOW="\033[0;33m"
readonly COLOR_NC="\033[0m"

# --- Configuration ---
verbose=false
debug_mode=false

# --- Functions ---

# @description Print error message to STDERR
# @arg $1 string Error message
# @output Error message to STDERR
function print_error() {
  printf "${COLOR_RED}Error: %s${COLOR_NC}\n" "$1" >&2
}

# @description Print info message to STDOUT if verbose
# @arg $1 string Info message
# @output Info message to STDOUT if verbose enabled
function print_info() {
  [[ "${verbose}" == true ]] && printf "${COLOR_GREEN}Info: %s${COLOR_NC}\n" "$1" || true
}

# @description Print warning message to STDERR
# @arg $1 string Warning message
# @output Warning message to STDERR
function print_warning() {
  printf "${COLOR_YELLOW}Warning: %s${COLOR_NC}\n" "$1" >&2
}

# @description Display usage information
# @output Usage information to STDERR
function usage() {
  cat << EOF >&2
${SCRIPT_NAME} - Update Git submodules and parent repository

Usage: ${SCRIPT_NAME} [OPTIONS]

Options:
  -h, --help       Display this help
  -v, --verbose    Enable verbose output
  --debug          Enable debug mode

Examples:
  # Basic usage
  ${SCRIPT_NAME}

  # Verbose mode
  ${SCRIPT_NAME} --verbose

  # Debug mode
  ${SCRIPT_NAME} --debug
EOF
  exit ${EXIT_USAGE}
}

# @description Clean up resources on exit
# @arg $1 integer Exit code
function cleanup() {
  local -r ret="$1"
  [[ "${debug_mode}" == true ]] && set +x

  if [[ -n "${root_dir:-}" && "$(pwd)" != "${root_dir}" ]]; then
    cd "${root_dir}" || print_error "Failed to return to ${root_dir}"
  fi

  if [[ ${ret} -ne ${EXIT_SUCCESS} ]]; then
    print_error "Script failed with exit code ${ret}"
    [[ -n "${last_command:-}" ]] && print_error "Last command: ${last_command}"
  fi

  exit "${ret}"
}

# @description Execute command with error handling
# @arg $@ string Command to execute
# @return Exit code of command
function run_command() {
  last_command="$*"
  print_info "Running: ${last_command}"
  if [[ "${verbose}" == true || "${debug_mode}" == true ]]; then
    "$@"
  else
    "$@" > /dev/null 2>&1
  fi
  local -r ret="$?"
  [[ ${ret} -ne 0 ]] && print_error "Command failed: ${last_command}"
  return "${ret}"
}

# @description Parse command line arguments
# @arg $@ array Command line arguments
function parse_arguments() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h | --help) usage ;;
      -v | --verbose) verbose=true ;;
      --debug)
        debug_mode=true
        set -x
        ;;
      *)
        print_error "Invalid argument: $1"
        usage
        ;;
    esac
    shift
  done
}

# @description Update all git submodules
# @arg $1 boolean Whether to merge changes
# @return Exit code of git submodule command
function update_submodules() {
  local -r merge="$1"
  if "${merge}"; then
    run_command git submodule update --remote --merge
  else
    run_command git submodule update --remote --checkout --force
  fi
}

function get_current_branch() {
  git branch --show-current
}

# @description Main function
# @arg $@ array Command line arguments
# @return Exit code
function main() {
  trap 'cleanup $?' EXIT
  parse_arguments "$@"

  # Validate environment
  for util in "${REQUIRED_UTILS[@]}"; do
    if ! command -v "${util}" > /dev/null; then
      print_error "Missing required utility: ${util}"
      exit ${EXIT_FAILURE}
    fi
  done

  # Get repository root
  local root_dir
  if ! root_dir="$(git rev-parse --show-toplevel)"; then
    print_error "Not in a Git repository"
    exit ${EXIT_FAILURE}
  fi
  cd "${root_dir}" || exit ${EXIT_FAILURE}

  initial_branch="$(get_current_branch)"

  readarray -t branches < <(git for-each-ref --format='%(refname:short)' refs/heads)

  for branch in "${branches[@]}"; do
    print_info "Processing branch: $branch"
    git checkout "$branch"
    # Update submodules
    update_submodules false || exit ${EXIT_FAILURE}

    # check if branch is dirty
    if ! git diff --quiet --ignore-submodules; then
      print_warning "Stash dirty files for branch: $branch"
      # stash dirty files
      git stash --include-untracked
    fi
    # Check if submodules are dirty
    if ! git diff --submodule --quiet; then
      run_command git add .
      run_command git commit -m "feat: Update submodules $(date +'%Y-%m-%d %H:%M:%S')"
      run_command git push origin "${branch}"
    fi
    # merge submodules
    update_submodules true
  done

  print_info "Switching back to ${initial_branch}"
  git switch "$initial_branch"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
