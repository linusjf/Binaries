#!/usr/bin/env bash
#
# Automates update of git submodules in parent repo.
# Checks out main/dev branches in each submodule owned by GITHUB_USERNAME,
# merges main into dev, pushes changes, and updates parent repo if submodules changed.
#
# @author Linus Fernandes (linusfernandes@gmail.com)
# @copyright Copyright (c) Linus Fernandes

# shellcheck disable=SC2155,SC1090,SC1091,SC2015
set -euo pipefail
shopt -s inherit_errexit
# --- Constants ---
readonly SCRIPT_NAME="$(basename "$0")"
readonly EXIT_SUCCESS=0
readonly EXIT_FAILURE=1
readonly EXIT_USAGE=2
readonly REQUIRED_UTILS=("git")
readonly MAIN_BRANCH_NAMES=("main" "master")

readonly COLOR_RED="\033[0;31m"
readonly COLOR_GREEN="\033[0;32m"
readonly COLOR_YELLOW="\033[0;33m"
readonly COLOR_NC="\033[0m"

# --- Configuration ---
verbose=false
debug_mode=false

# --- Functions ---

# @description Print error message to STDERR
# @arg $1 string Error message
# @output Error message to STDERR
function print_error() {
  printf "${COLOR_RED}Error: %s${COLOR_NC}\n" "$1" >&2
}

# @description Print info message to STDOUT if verbose
# @arg $1 string Info message
# @output Info message to STDOUT if verbose enabled
function print_info() {
  [[ "${verbose}" == true ]] && printf "${COLOR_GREEN}Info: %s${COLOR_NC}\n" "$1" || true
}

# @description Print warning message to STDERR
# @arg $1 string Warning message
# @output Warning message to STDERR
function print_warning() {
  printf "${COLOR_YELLOW}Warning: %s${COLOR_NC}\n" "$1" >&2
}

# @description Display usage information
# @output Usage information to STDERR
function usage() {
  cat << EOF >&2
${SCRIPT_NAME} - Update Git submodules and parent repository

Usage: ${SCRIPT_NAME} [OPTIONS]

Options:
  -h, --help       Display this help
  -v, --verbose    Enable verbose output
  --debug          Enable debug mode

Examples:
  # Basic usage
  ${SCRIPT_NAME}

  # Verbose mode
  ${SCRIPT_NAME} --verbose

  # Debug mode
  ${SCRIPT_NAME} --debug
EOF
  exit ${EXIT_USAGE}
}

# @description Clean up resources on exit
# @arg $1 integer Exit code
function cleanup() {
  local -r ret="$1"
  [[ "${debug_mode}" == true ]] && set +x

  if [[ -n "${root_dir:-}" && "$(pwd)" != "${root_dir}" ]]; then
    cd "${root_dir}" || print_error "Failed to return to ${root_dir}"
  fi

  if [[ ${ret} -ne ${EXIT_SUCCESS} ]]; then
    print_error "Script failed with exit code ${ret}"
    [[ -n "${last_command:-}" ]] && print_error "Last command: ${last_command}"
  fi

  exit "${ret}"
}

# @description Execute command with error handling
# @arg $@ string Command to execute
# @return Exit code of command
function run_command() {
  last_command="$*"
  print_info "Running: ${last_command}"
  if [[ "${verbose}" == true || "${debug_mode}" == true ]]; then
    "$@"
  else
    "$@" > /dev/null 2>&1
  fi
  local -r ret="$?"
  [[ ${ret} -ne 0 ]] && print_error "Command failed: ${last_command}"
  return "${ret}"
}

# @description Parse command line arguments
# @arg $@ array Command line arguments
function parse_arguments() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h | --help) usage ;;
      -v | --verbose) verbose=true ;;
      --debug)
        debug_mode=true
        set -x
        ;;
      *)
        print_error "Invalid argument: $1"
        usage
        ;;
    esac
    shift
  done
}

# @description Get main branch name
# @stdout Main branch name
# @return 0 if successful, 1 otherwise
function get_main_branch() {
  local remote_head_ref
  remote_head_ref="$(git symbolic-ref refs/remotes/origin/HEAD 2> /dev/null || echo "")"

  for name in "${MAIN_BRANCH_NAMES[@]}"; do
    if [[ "${remote_head_ref##*/}" == "${name}" ]]; then
      echo "${name}"
      return ${EXIT_SUCCESS}
    fi
  done

  for name in "${MAIN_BRANCH_NAMES[@]}"; do
    if git show-ref --verify --quiet "refs/heads/${name}"; then
      echo "${name}"
      return ${EXIT_SUCCESS}
    fi
  done

  local branch_count
  branch_count="$(git branch --list | wc -l | tr -d ' ')"
  if [[ "${branch_count}" -eq 1 ]]; then
    local single_branch
    single_branch="$(git branch --show-current)"
    print_info "Only one branch found (${single_branch}), using as main branch"
    echo "${single_branch}"
    return ${EXIT_SUCCESS}
  fi

  print_error "Could not determine main branch"
  return ${EXIT_FAILURE}
}

# @description Check if branch exists
# @arg $1 string Branch name
# @return 0 if branch exists, 1 otherwise
function branch_exists() {
  git rev-parse --verify --quiet "refs/heads/$1" > /dev/null
}

# @description Update all git submodules
# @arg $1 boolean Whether to merge changes
# @return Exit code of git submodule command
function update_submodules() {
  local -r merge="$1"
  if "${merge}"; then
    run_command git submodule update --remote --merge
  else
    run_command git submodule update --remote --checkout --force
  fi
}

# @description Main function
# @arg $@ array Command line arguments
# @return Exit code
function main() {
  trap 'cleanup $?' EXIT
  parse_arguments "$@"

  # Validate environment
  for util in "${REQUIRED_UTILS[@]}"; do
    if ! command -v "${util}" > /dev/null; then
      print_error "Missing required utility: ${util}"
      exit ${EXIT_FAILURE}
    fi
  done

  # Get repository root
  local root_dir
  if ! root_dir="$(git rev-parse --show-toplevel)"; then
    print_error "Not in a Git repository"
    exit ${EXIT_FAILURE}
  fi
  cd "${root_dir}" || exit ${EXIT_FAILURE}

  readarray -t branches < <(git for-each-ref --format='%(refname:short)' refs/heads)

  for branch in "${branches[@]}"; do
    # Remove the '*' character that indicates the current branch
    branch="${branch#*}"
    echo "Processing branch: $branch"
    # Update submodules
    update_submodules false || exit ${EXIT_FAILURE}

    # Commit changes if needed
    if ! git diff --submodule --quiet; then
      run_command git add .
      run_command git commit -m "feat: Update submodules $(date +'%Y-%m-%d %H:%M:%S')"
      run_command git push origin "${branch}"
    fi
    # merge submodules
    update_submodules true
  done

}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
