#!/usr/bin/env bash
#
# Automates update of git submodules in parent repo.
# Checks out main/dev branches in each submodule owned by GITHUB_USERNAME,
# merges main into dev, pushes changes, and updates parent repo if submodules changed.
#
# @author Linus Fernandes (linusfernandes@gmail.com)
# @copyright Copyright (c) Linus Fernandes

# shellcheck disable=SC2155,SC1090,SC1091,SC2015
set -euo pipefail
shopt -s inherit_errexit

# --- Constants ---
readonly SCRIPT_NAME=$(basename "$0")
readonly EXIT_SUCCESS=0
readonly EXIT_FAILURE=1
readonly EXIT_USAGE=2
readonly REQUIRED_UTILS=("git")
readonly MAIN_BRANCH_NAMES=("main" "master")
readonly DEV_BRANCH="development"

readonly COLOR_RED="\033[0;31m"
readonly COLOR_GREEN="\033[0;32m"
readonly COLOR_YELLOW="\033[0;33m"
readonly COLOR_NC="\033[0m"
verbose=false

# --- Functions ---

# @description Print error message to STDERR
# @arg $1 string Error message
function print_error() {
  printf "${COLOR_RED}Error: %s${COLOR_NC}\n" "$1" >&2
}

# @description Print info message to STDOUT if verbose
# @arg $1 string Info message
function print_info() {
  [[ "${verbose}" == true ]] && printf "${COLOR_GREEN}Info: %s${COLOR_NC}\n" "$1" || true
}

# @description Print warning message to STDERR
# @arg $1 string Warning message
function print_warning() {
  printf "${COLOR_YELLOW}Warning: %s${COLOR_NC}\n" "$1" >&2
}

# @description Display usage information
function usage() {
  cat << EOF >&2
${SCRIPT_NAME} - Update Git submodules and parent repository

Usage: ${SCRIPT_NAME} [OPTIONS]

Options:
  -h, --help       Display this help
  -v, --verbose    Enable verbose output
  --debug          Enable debug mode

Examples:
  ${SCRIPT_NAME}
  ${SCRIPT_NAME} --verbose
EOF
  exit ${EXIT_USAGE}
}

# @description Clean up resources on exit
function cleanup() {
  local -r ret=$?
  set +x

  if [[ -n "${root_dir}" && "$(pwd)" != "${root_dir}" ]]; then
    cd "${root_dir}" || print_error "Failed to return to ${root_dir}"
  fi

  if [[ ${ret} -ne ${EXIT_SUCCESS} ]]; then
    print_error "Script failed with exit code ${ret}"
    [[ -n "${last_command}" ]] && print_error "Last command: ${last_command}"
  fi

  exit ${ret}
}

# @description Execute command with error handling
# @arg $@ string Command to execute
function run_command() {
  last_command="$*"
  print_info "Running: ${last_command}"
  if [[ "${verbose}" = true ]]; then
    "$@"
  else
    "$@" > /dev/null 2>&1
  fi
  local -r ret=$?
  [[ ${ret} -ne 0 ]] && print_error "Command failed: ${last_command}"
  return ${ret}
}

# @description Parse command line arguments
# @arg $@ array Command line arguments
function parse_arguments() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h | --help) usage ;;
      -v | --verbose) verbose=true ;;
      --debug)
        set -x
        ;;
      *)
        print_error "Invalid argument: $1"
        usage
        ;;
    esac
    shift
  done
}

# @description Get main branch name
# @stdout Main branch name
function get_main_branch() {
  local remote_head_ref
  remote_head_ref=$(git symbolic-ref refs/remotes/origin/HEAD 2> /dev/null || echo "")

  for name in "${MAIN_BRANCH_NAMES[@]}"; do
    if [[ "${remote_head_ref##*/}" == "${name}" ]]; then
      echo "${name}"
      return ${EXIT_SUCCESS}
    fi
  done

  for name in "${MAIN_BRANCH_NAMES[@]}"; do
    if git show-ref --verify --quiet "refs/heads/${name}"; then
      echo "${name}"
      return ${EXIT_SUCCESS}
    fi
  done

  # Check if there's only one branch
  local branch_count
  branch_count=$(git branch --list | wc -l | tr -d ' ')
  if [[ "${branch_count}" -eq 1 ]]; then
    local single_branch
    single_branch=$(git branch --show-current)
    print_info "Only one branch found (${single_branch}), using as main branch"
    echo "${single_branch}"
    return ${EXIT_SUCCESS}
  fi

  print_error "Could not determine main branch"
  return ${EXIT_FAILURE}
}

# @description Check if branch exists
# @arg $1 string Branch name
function branch_exists() {
  git rev-parse --verify --quiet "refs/heads/$1" > /dev/null
}

# @description Update all git submodules
function update_submodules() {
  merge="$1"
  if "$merge"; then
    run_command git submodule update --remote --merge
  else
    run_command git submodule update --remote --checkout --force
  fi
}

# @description Main function
function main() {
  trap cleanup EXIT
  parse_arguments "$@"

  # Validate environment
  for util in "${REQUIRED_UTILS[@]}"; do
    if ! command -v "${util}" > /dev/null; then
      print_error "Missing required utility: ${util}"
      exit ${EXIT_FAILURE}
    fi
  done

  local dev_exists=branch_exists "${DEV_BRANCH}"
  # Get repository root
  if ! root_dir="$(git rev-parse --show-toplevel)"; then
    print_error "Not in a Git repository"
    exit ${EXIT_FAILURE}
  fi
  cd "${root_dir}" || exit ${EXIT_FAILURE}

  # Store initial branch
  local -r initial_branch=$(git rev-parse --abbrev-ref HEAD)
  local -r parent_main_br=$(get_main_branch) || exit ${EXIT_FAILURE}

  # Check development branch exists remotely
  if [[ "$initial_branch" != "$DEV_BRANCH" ]]; then
    if ! "$dev_exists"; then
      if git rev-parse --verify --quiet "origin/${DEV_BRANCH}" > /dev/null; then
        run_command git checkout -t "origin/${DEV_BRANCH}"
        dev_exists=true
      fi
      run_command git switch "${initial_branch}"
    fi
  fi

  local target_branch=""
  local one_branch_only=false
  if [[ "$initial_branch" == "$DEV_BRANCH" ]] && [[ "$parent_main_br" == "$DEV_BRANCH" ]]; then
    one_branch_only=true
  elif [[ "$initial_branch" == "$DEV_BRANCH" ]] && [[ "$parent_main_br" != "$DEV_BRANCH" ]]; then
    target_branch="$parent_main_br"
  else
    "$dev_exists" && target_branch="${DEV_BRANCH}" 
  fi

  # Update submodules
  update_submodules false || exit ${EXIT_FAILURE}

  # Commit changes if needed
  if ! git diff --submodule --quiet; then
    run_command git branch
    run_command git add .
    run_command git commit -m "feat: Update submodules $(date +'%Y-%m-%d %H:%M:%S')"
    run_command git push origin "${initial_branch}"
    if ! "${one_branch_only}"; then
      run_command git switch "${target_branch}"
      run_command git pull
      run_command git merge "${initial_branch}"
      run_command git push
      run_command git switch "$initial_branch"
    fi
  fi
  update_submodules true
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
