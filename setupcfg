#!/usr/bin/env bash

# Print a warning message in yellow
function warn() {
  printf "\033[1;33m%s\033[0m\n" "$1"
}

# Print an informational message in cyan
function info() {
  printf "\033[1;36m%s\033[0m\n" "$1"
}

# Print an error message in red to stderr
function error() {
  printf "\033[1;31m%s\033[0m\n" "$1" >&2
}

# Link configuration files from Configurations directory to home directory
# Args: List of configuration files/directories to link
# Returns: 0 if all links created successfully, 1 otherwise
function link_configurations() {
  local ret=0
  local config_dir="$HOME/Configurations"
  local home_dir="$HOME"

  # Verify Configurations directory exists
  if [ ! -d "$config_dir" ]; then
    error "$config_dir directory does not exist."
    return 1
  fi

  # Process each requested configuration item
  for item in "$@"; do
    local item_path="$config_dir/$item"
    local link_path="$home_dir/$item"

    # Skip if source item doesn't exist
    if [ ! -e "$item_path" ]; then
      warn "$item_path does not exist."
      continue
    fi

    # Handle existing files/directories at link location
    if [ -e "$link_path" ]; then
      # For regular files
      if [ -f "$link_path" ]; then
        # Backup existing file before replacing
        if ! cp --backup=numbered "${link_path}" "${link_path}.old"; then
          error "Failed to backup ${link_path}"
          ((ret = 1))
          continue
        fi
        rm "${link_path}"
      # For directories
      elif [ -d "$link_path" ]; then
        # Handle symlinked directories
        if [[ -L "$link_path" ]]; then
          local real_path
          real_path="$(readlink "$link_path")"
          if [[ -e "$real_path" ]]; then
            # Skip if already linked to Configurations
            if [[ "$real_path" == *Configurations* ]]; then
              warn "Skipped ${link_path} --> ${real_path}"
              continue
            else
              warn "Removing ${link_path} --> ${real_path}."
            fi
          fi
        # Handle regular directories
        else
          # Backup existing directory before replacing
          if ! cp --backup=numbered -r "${link_path}" "${link_path}.old"; then
            error "Failed to backup ${link_path}"
            ((ret = 1))
            continue
          fi
          rm -r "${link_path}"
        fi
      fi
    fi

    # Create symbolic link
    if ! ln -sf "$item_path" "$link_path"; then
      error "Failed to create link: $link_path --> $item_path"
      ((ret = 1))
    else
      info "$link_path --> $item_path"
    fi
  done

  return "$ret"
}

# Verify required commands are available
# Args: List of command dependencies to check
# Returns: 0 if all dependencies found, 1 otherwise
function require() {
  local missing_deps=()

  # Check each dependency
  for dep in "$@"; do
    if ! command -v "$dep" &> /dev/null; then
      missing_deps+=("$dep")
    fi
  done

  # Report any missing dependencies
  if [ ${#missing_deps[@]} -gt 0 ]; then
    error "The following dependencies were not found:"
    for dep in "${missing_deps[@]}"; do
      error "  - $dep"
    done
    return 1
  fi
}

# Handle special case for .git directory configuration
# Returns: 0 if successful, 1 on error
function handle_git_config() {
  # If .git is already a symlink
  if [[ -L "${HOME}/.git" ]]; then
    if ! ln -sf "${HOME}/Configurations/git" "${HOME}/.git"; then
      error "Failed to create git config link"
      return 1
    fi
  # If .git is a regular directory
  else
    if ! cp -r "${HOME}/.git" "${HOME}/.git.old"; then
      error "Failed to backup .git config"
      return 1
    fi
    ln -sf "${HOME}/Configurations/git" "${HOME}/.git"
  fi
}

# Main function to coordinate setup process
function main() {
  # Enable strict error handling
  set -euo pipefail
  shopt -s inherit_errexit

  # Verify required commands are available
  require cp rm ln

  # Link common configuration files
  link_configurations .bashrc .bash_profile .bash_aliases .bash_logout \
    .gitconfig .gitrc .github .gitguardian.yml .emacs .sqliterc .ssh .termux .tmux.conf \
    .vimrc .jupyter .aider.conf.yml .aider.model.settings.yml templates

  # Handle git configuration
  handle_git_config
}

# Execute main function
main "$@"
exit 0
