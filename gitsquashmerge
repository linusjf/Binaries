#!/usr/bin/env bash
set -e

# Optional dry run mode
dry_run=false
if [[ "$1" == "--dry-run" ]]; then
  dry_run=true
  echo "[DRY RUN] No actual changes will be made."
fi

original_branch=$(git rev-parse --abbrev-ref HEAD)
commits=("$(git log --pretty=format:'%H%x09%s')")

latest_msg=$(echo "${commits[0]}" | cut -f2)
hashes_to_squash=()

for commit in "${commits[@]}"; do
  hash=$(echo "$commit" | cut -f1)
  msg=$(echo "$commit" | cut -f2-)
  if [[ "$msg" == "$latest_msg" ]]; then
    hashes_to_squash+=("$hash")
  else
    break
  fi
done

if [[ ${#hashes_to_squash[@]} -le 1 ]]; then
  echo "Only one commit with message '$latest_msg'. Nothing to squash."
  exit 0
fi

last_to_keep="${hashes_to_squash[-1]}"

if ! git merge-base --is-ancestor "$last_to_keep" main; then
  echo "These commits are not in 'main'. Aborting."
  exit 1
fi

echo "Preparing to squash ${#hashes_to_squash[@]} commits into one:"
echo "  \"$latest_msg\""
echo "This will rewrite the history of 'main'."

if [[ "$dry_run" == false ]]; then
  read -r -p "Type YES to proceed: " confirm
  if [[ "$confirm" != "YES" ]]; then
    echo "Aborted."
    exit 1
  fi
fi

# Backup current main
timestamp=$(date +%Y%m%d%H%M%S)
backup_tag="backup-main-$timestamp"
if [[ "$dry_run" == false ]]; then
  git tag "$backup_tag" main
  echo "Backup tag '$backup_tag' created for current main."
else
  echo "[DRY RUN] Would tag current main as '$backup_tag'"
fi

# Create temp branch and cherry-pick
base_commit=$(git merge-base "${hashes_to_squash[-1]}" main)
temp_branch="temp-main-rewrite-$timestamp"

if [[ "$dry_run" == false ]]; then
  git checkout -b "$temp_branch" "$base_commit"
  for ((i = ${#hashes_to_squash[@]} - 1; i >= 0; i--)); do
    git cherry-pick --no-commit "${hashes_to_squash[$i]}" || {
      echo "Conflict during cherry-pick. Resolve manually."
      exit 1
    }
  done
  git commit -m "$latest_msg"
  git branch -f main
  git checkout main
  git reset --hard "$temp_branch"

  read -r -p "Force-push new squashed 'main' to origin? (y/N): " push_confirm
  if [[ "$push_confirm" == "y" || "$push_confirm" == "Y" ]]; then
    git push origin main --force
    echo "'main' successfully rewritten and pushed."
  else
    echo "Push skipped. You can push manually with: git push origin main --force"
  fi
else
  echo "[DRY RUN] Would create temp branch from $base_commit and cherry-pick commits"
  echo "[DRY RUN] Would squash and force-push to origin/main"
fi

# Check if current branch needs update
if [[ "$original_branch" != "main" ]]; then
  echo "Checking if '$original_branch' contains original commits..."
  needs_update=false
  for hash in "${hashes_to_squash[@]}"; do
    if git merge-base --is-ancestor "$hash" "$original_branch"; then
      needs_update=true
      break
    fi
  done

  if [[ "$needs_update" == "true" ]]; then
    echo "Current branch '$original_branch' contains the old commits."
    if [[ "$dry_run" == false ]]; then
      read -r -p "Rebase '$original_branch' onto new 'main'? (y/N): " rebase_confirm
      if [[ "$rebase_confirm" == "y" || "$rebase_confirm" == "Y" ]]; then
        git checkout "$original_branch"
        git rebase main
        echo "'$original_branch' rebased onto new 'main'."
      else
        read -r -p "Hard reset '$original_branch' to 'main' instead? (y/N): " reset_confirm
        if [[ "$reset_confirm" == "y" || "$reset_confirm" == "Y" ]]; then
          git checkout "$original_branch"
          git reset --hard main
          echo "'$original_branch' reset to 'main'."
        else
          echo "No changes made to '$original_branch'."
        fi
      fi
    else
      echo "[DRY RUN] Would prompt to rebase or reset '$original_branch' onto 'main'"
    fi
  fi
fi
